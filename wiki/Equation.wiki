#summary Tutorial on using the Equations API

= Introduction =

Writing succinct and readable linear algebra code in Java using any library is problematic.  Originally EJML just offered two API's for performing linear algebra.  A procedural API which provided complete control over memory and which algorithms were used, but was verbose and had a sharper learning curve.  Alternatively you could use an easy to use object oriented API but lose control over memory and had a limited set of operators.  Neither of these API's produces code which is all that similar to how equations are written mathematically.

Languages, such as Matlab, are specifically designed for processing matrices and are much closer to mathematical notation.  C++ offers the ability to overload operators allowing for more natural code, see Eigen.  To overcome this problem EJML now provides the _Equation_ API which allows a Matlab/Octave like notation to be used.

This is achieved by parsing text strings with equations and converting it into a set of executable instructions.  Below is an example comparing the different API's offered in EJML.

Equations
{{{
eq.process("K = P*H'*inv( H*P*H' + R )");
}}}

SimpleMatrix
{{{
SimpleMatrix S = H.mult(P).mult(H.transpose()).plus(R);
SimpleMatrix K = P.mult(H.transpose().mult(S.invert()));
}}}

Procedural
{{{
mult(H,P,c);
multTransB(c,H,S);
addEquals(S,R);
if( !invert(S,S_inv) ) throw new RuntimeException("Invert failed");
multTransA(H,S_inv,d);
mult(P,d,K);
}}}

The equations code is more compact and readable than the two alternatives.  While the syntax is heavily inspired by Matlab and its kin, it does not attempt to replicate its functionality.  It is also not a replacement for SimpleMatrix or the procedural API.  There are situations where those other interfaces are easier to use and most applications would need to use a mix.

Equations is designed to have minimal overhead.  It runs almost as fast as the procedural API and can be used such that all memory predeclared.  Predeclaring memory is particularly important in embedded applications.

= Quick Start =

The syntax used in Equation is very similar to Matlab and other computer algebra systems (CAS).  It is assumed the reader is already familiar with these systems and can quickly pick up the syntax through these examples.

Let's start with a complete simple example then explain what's going on line by line.

{{{
01: public void updateP( DenseMatrix64F P , DenseMatrix64F F , DenseMatrix64F Q ) {
02:     Equation eq = new Equation();
03:     eq.alias(P,"P",F,"F",Q,"Q");
04:     eq.process("S = F*P*F'");
05:     eq.process("P = S + Q");
06: }
}}}

Line 02: Declare the Equation class.
Line 03: Create aliases for each variable.  This allowed Equation to reference and manipulate those classes.
Line 04: Process(0 is called and passed in a text string with an equation in it.  The variable 'S' is lazily created and set to the result of F*P*F'.
Line 05: Process() is called again and P is set to the result of adding S and Q together.  Because P is aliased to the input matrix P that matrix is changed.

Three types of variables are supported, matrix, double, and integer.  Results can be stored in each type and all can be aliased.  The example below uses all 3 data types and to compute the likelihood of "x" from a multivariable normal distribution defined by matrices 'mu' and 'P'.
{{{
eq.alias(x.numRows,"k",P,"P",x,"x",mu,"mu");
eq.process("p = (2*pi)^(-k/2)/sqrt(det(P))*exp(-0.5*(x-mu)'*inv(P)*(x-mu))");
}}}
The end result 'p' will be a double.  There was no need to alias 'pi' since it's a built in constant.  Since 'p' is lazily defined how do you access the result?
{{{
double p = eq.lookupDouble("p");
}}}
For a matrix you could use eq.lookupMatrix() and eq.lookupInteger() for integers.  If you don't know the variable's type then eq.lookupVariable() is what you need.

It is also possible to define a matrix inline:
{{{
eq.process("P = [10 0 0;0 10 0;0 0 10]");
}}}
Will assign P to a 3x3 matrix with 10's all along it's diagonal.  Other matrices can also be included inside:
{{{
eq.process("P = [A ; B]");
}}}
will concatenate A and B horizontally.

Submatrices are also supported for assignment and reference.
{{{
eq.process("P(2:5,0:3) = 10*A(1:4,10:13)");
}}}
P(2:5,0:3) references the sub-matrix inside of P from rows 2 to 5 (inclusive) and columns 0 to 3 (inclusive).

This concludes the quick start tutorial.  The remaining sections will go into more detail on each of the subjects touched upon above.

= The Compiler =

= Aliasing =

First step to using equations is to declare the Equations class.
{{{
Equation eq = new Equation();
}}}

To manipulate matrices in equations they need to be aliased.  DenseMatrix64F and SimpleMatrix can be aliased.  A copy of scalar numbers can also be aliased.  When a variable is aliased a reference to the data is saved and a name associated with it.
{{{
DenseMatrix64F x = new DenseMatrix64F(6,1);
eq.alias(x,"x");
}}}
Multiple variables can be aliased at the same time too
{{{
eq.alias(x,"x",P,"P",h,"Happy");
}}}
As is shown above the string name for a variable does not have to be the same as Java name of the variable.  Here is an example where an integer and double is aliased.
{{{
int a = 6;
eq.alias(2.3,"distance",a,"a");
}}}

After a variable has been aliased you can alias the same name again to change it.  Here is an example of just that:
{{{
for( int i = 0; i < 10; i++ ) {
    eq.alias(i,"i");
}
}}}

OVERRIDING BUILT IN FUNCTIONS AND VARIABLES

= Submatrices =

= Inline Matrix =

= Built in Functions and Variables =

= Future Work =